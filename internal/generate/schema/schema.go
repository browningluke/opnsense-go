package schema

import (
	"fmt"
	"os"

	"gopkg.in/yaml.v3"
)

type AttrData struct {
	Name      string `yaml:"name"`
	Type      string `yaml:"type"`
	Key       string `yaml:"key"`
	OmitEmpty bool   `yaml:"omitEmpty"`
}

func (a *AttrData) UnmarshalYAML(unmarshal func(interface{}) error) error {
	// Unmarshal to map first
	d := make(map[string]string)
	err := unmarshal(&d)
	if err != nil {
		panic(err)
	}

	// Build AttrData from map
	a.Name = d["name"]
	a.Type = d["type"]
	a.Key = d["key"]

	a.OmitEmpty = false
	if d["omitEmpty"] == "true" {
		a.OmitEmpty = true
	}

	// Remap types to correct Go code
	if d["type"] == "SelectedMap" {
		a.Type = "api.SelectedMap"
	} else if d["type"] == "SelectedMapList" {
		a.Type = "api.SelectedMapList"
	} else if d["type"] == "SelectedMapListNL" {
		a.Type = "api.SelectedMapListNL"
	}

	return nil
}

type ResourceData struct {
	Name      string `yaml:"name"`
	Filename  string `yaml:"filename"`
	Monad     string `yaml:"monad"`
	Endpoints struct {
		Add         string `yaml:"add"`
		Get         string `yaml:"get"`
		Update      string `yaml:"update"`
		Delete      string `yaml:"delete"`
		Reconfigure string `yaml:"reconfigure,omitempty"`
	}
	ReadOnly    bool `yaml:"readOnly"`
	GetByFilter bool `yaml:"getByFilter"`
	GetAll      bool `yaml:"getAll"`

	ReconfigureEndpointVariable string // autogenerated

	Attrs       []AttrData            `yaml:"attrs"`
	CustomTypes map[string][]AttrData `yaml:"customTypes"`
}

type RPCData struct {
	Name        string                `yaml:"name"`
	Filename    string                `yaml:"filename"`
	RPCCalls    []RPCCallData         `yaml:"rpc_calls"`
	CustomTypes map[string][]AttrData `yaml:"customTypes"`
}

type Parameter struct {
	Name     string `yaml:"name"`
	Optional bool   `yaml:"optional"`
	IsBodyParameter bool `yaml:"bodyParameter"`
}

type RPCCallData struct {
	Name       string      `yaml:"name"`
	Endpoint   string      `yaml:"endpoint"`
	Method     string      `yaml:"method"`
	Parameters []Parameter `yaml:"params"`
	ResultType string      `yaml:"result_type"`
}

type ControllerData struct {
	Name                string         `yaml:"name"`
	ReconfigureEndpoint string         `yaml:"reconfigureEndpoint"`
	Resources           []ResourceData `yaml:"resources"`
	RPC                 []RPCData      `yaml:"rpc"`
}

func newController(file string) *ControllerData {
	yamlFile, err := os.ReadFile(file)
	if err != nil {
		panic(err)
	}

	c := &ControllerData{}
	err = yaml.Unmarshal(yamlFile, c)
	if err != nil {
		panic(err)
	}

	// Calculate ReconfigureEndpointVariable for all resources
	for i, r := range c.Resources {
		if r.Endpoints.Reconfigure != "" {
			c.Resources[i].ReconfigureEndpointVariable = fmt.Sprintf("%s%sReconfigureEndpoint", c.Name, r.Name)
		} else {
			c.Resources[i].ReconfigureEndpointVariable = fmt.Sprintf("%sReconfigureEndpoint", c.Name)
		}
	}

	return c
}

func GetController(name string) *ControllerData {
	p := fmt.Sprintf("%s/%s.yml", relativePathToSchema, name)

	// Check if controller schema file exists
	if _, err := os.Stat(p); os.IsNotExist(err) {
		return nil
	}

	// Load controller schema
	return newController(p)
}

func GetControllerNames() []string {
	files, err := os.ReadDir(relativePathToSchema)
	if err != nil {
		panic(err)
	}

	var controllerNames []string
	for _, file := range files {
		controllerNames = append(
			controllerNames,
			// Get load controller name from schema file
			newController(fmt.Sprintf("%s/%s", relativePathToSchema, file.Name())).Name,
		)
	}
	return controllerNames
}

var relativePathToSchema = "../../schema"
